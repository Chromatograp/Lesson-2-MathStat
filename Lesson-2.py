# -*- coding: utf-8 -*-
"""Копия 2.3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ckpt4Wdw_gzuF8bpy46rIZ-2QijoOxzY
"""

from math import factorial
import numpy as np
import math

print('Задание 1.')

# Вероятность того, что стрелок попадет в мишень, выстрелив один раз, равна 0.8.
# Стрелок выстрелил 100 раз. Найдите вероятность того, что стрелок попадет в
# цель ровно 85 раз.

# Количество испытаний слишком велико для применения биномиального распределения,
# вероятность появления события слишком велика для применения распределения
# Пуассона, поэтому справедливо будет проведение примерных расчетов с помощью 
# локальной теоремы Лапласа:

def shot(m, n, p):
  x = ((m - n * p)/(np.sqrt(n * p * (1 - p)))) ** 2
  e = math.e
  return (1 / np.sqrt(n * p * (1 - p))) * (1 / np.sqrt(2 * np.pi)) * np.power(math.e, -x / 2)

print('Вероятность, что стрелок попадет в цель 85 раз:', "{:.4f}".format(shot(85, 100, 0.8)))

print('Задание 2.')

# Вероятность того, что лампочка перегорит в течение первого дня эксплуатации,
# равна 0.0004. В жилом комплексе после ремонта в один день включили 5000 новых
# лампочек. Какова вероятность, что ни одна из них не перегорит в первый день?
# Какова вероятность, что перегорят ровно две?

# В данном случае количество испытаний слишком велико для применения биномиального
# распределения, а вероятность события слишком мала для применения локальной
# теоремы Лапласа, поэтому лучше всего для вычислений подходит распределение
# Пуассона:

def lamp(n, m, p):
  lambda_1 = p * n
  return ((lambda_1 ** m) / factorial(m)) * math.e ** -lambda_1

print('Вероятность того, что в первый день не перегорит ни одна лампочка:', "{:.3f}".format(lamp(5000, 0, 0.0004)))
print('Вероятность того, что две лампочки перегорят в первый день', "{:.3f}".format(lamp(5000, 2, 0.0004)))

print('Задание 3.')

# Монету подбросили 144 раза. Какова вероятность, что орел выпадет ровно 70 раз?

# Поскольку количество испытаний слишком велико для применения биномиального
# закона, а вероятность наступления события слишком велика для применения
# распределения Пуассона, справедливо будет использовать локальную теорему
# Лапласа:

def coin(m, n, p):
  x = ((m - n * p)/(np.sqrt(n * p * (1 - p)))) ** 2
  e = math.e
  return (1 / np.sqrt(n * p * (1 - p))) * (1 / np.sqrt(2 * np.pi)) * np.power(math.e, -x / 2)

print('Вероятность, что орел выпадет ровно 70 раз:', "{:.3f}".format(coin(70, 144, 0.5)))

print('Задание 4.')

# В первом ящике находится 10 мячей, из которых 7 - белые. Во втором ящике - 11
# мячей, из которых 9 белых. Из каждого ящика вытаскивают случайным образом по
# два мяча.
# Какова вероятность того, что все мячи белые?
# Какова вероятность того, что ровно два мяча белые?
# Какова вероятность того, что хотя бы один мяч белый?

# Чтобы ответить на первый вопрос, сначала установим вероятность вынуть два белых
# мяча из каждой выборки. Произведение этих вероятностей характеризует общую
# вероятность:

def balls(n, k):
  return (k/n) * ((k-1)/(n-1))

box_1 = balls(10, 7)
box_2 = balls(11, 9)

print('Все мячи будут белыми с вероятностью', "{:.3f}".format(box_1 * box_2))

# Чтобы ответить на второй вопрос, можно найти сумму вероятностей возникновения
# всех возможных событий:

def balls_1(n1, k1, n2, k2):
  substr_1 = n1 - k1
  substr_2 = n2 - k2
  B1 = (k1/n1) * ((k1-1)/(n1-1)) * (substr_2/n2) * ((substr_2-1)/(n2-1))
  B2 = (substr_1/n1) * ((substr_1-1)/(n1-1)) * (k2/n2) * ((k2-1)/(n2-1))
  B3 = (k1/n1) * ((substr_1)/(n1-1)) * (k2/n2) * ((substr_2)/(n2-1))
  B4 = (k1/n1) * ((substr_1)/(n1-1)) * (substr_2/n2) * ((k2)/(n2-1))
  B5 = (substr_1/n1) * ((k1)/(n1-1)) * (k2/n2) * ((substr_2)/(n2-1))
  B6 = (substr_1/n1) * ((k1)/(n1-1)) * (substr_2/n2) * ((k2)/(n2-1))
  return B1 + B2 + B3 + B4 + B5 + B6

print('Среди выбранных будет два белых мяча с вероятностью', "{:.4f}".format(balls_1(10, 7, 11, 9))) 

# Для ответа на третий вопрос можно вычислить вероятность получения выборки
# совсем без белых шаров и отнять от единицы:

def balls_2(n1, n2, k1, k2, t):
  C1 = (factorial(n1)/(factorial(t) * factorial(n1 - t)))
  C2 = (factorial(n2)/(factorial(t) * factorial(n2 - t)))
  C3 = (factorial(k1)/(factorial(t) * factorial(k1 - t)))
  C4 = (factorial(k2)/(factorial(t) * factorial(k2 - t)))
  B1 = C1 - C2
  B2 = C3 - C4
  return 1 - ((B1 / C1) * (B2 / C2))

print('Среди выбранных будет не менее 1 белого мяча с вероятностью', "{:.4f}".format(balls_2(10, 11, 7, 9, 2)))